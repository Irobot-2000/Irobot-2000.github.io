import"./index-DIP_7Pq0.js";import"https://cdnjs.cloudflare.com/ajax/libs/simple-peer/9.11.1/simplepeer.min.js";function We(){}function C(e){return typeof e=="object"&&e!==null||typeof e=="function"}var wt=We;function v(e,r){try{Object.defineProperty(e,"name",{value:r,configurable:!0})}catch{}}var zr=Promise,To=Promise.resolve.bind(zr),Po=Promise.prototype.then,qo=Promise.reject.bind(zr),Co=To;function j(e){return new zr(e)}function g(e){return j(r=>r(e))}function d(e){return qo(e)}function D(e,r,t){return Po.call(e,r,t)}function F(e,r,t){D(D(e,r,t),void 0,wt)}function fr(e,r){F(e,r)}function wr(e,r){F(e,void 0,r)}function H(e,r,t){return D(e,r,t)}function qe(e){D(e,void 0,wt)}var fe=e=>{if(typeof queueMicrotask=="function")fe=queueMicrotask;else{const r=g(void 0);fe=t=>D(r,t)}return fe(e)};function he(e,r,t){if(typeof e!="function")throw new TypeError("Argument is not a function");return Function.prototype.apply.call(e,r,t)}function U(e,r,t){try{return g(he(e,r,t))}catch(o){return d(o)}}var L=class{constructor(){this._cursor=0,this._size=0,this._front={_elements:[],_next:void 0},this._back=this._front,this._cursor=0,this._size=0}get length(){return this._size}push(e){const r=this._back;let t=r;r._elements.length===16383&&(t={_elements:[],_next:void 0}),r._elements.push(e),t!==r&&(this._back=t,r._next=t),++this._size}shift(){const e=this._front;let r=e;const t=this._cursor;let o=t+1;const i=e._elements,n=i[t];return o===16384&&(r=e._next,o=0),--this._size,this._cursor=o,e!==r&&(this._front=r),i[t]=void 0,n}forEach(e){let r=this._cursor,t=this._front,o=t._elements;for(;!(r===o.length&&t._next===void 0||r===o.length&&(t=t._next,o=t._elements,r=0,o.length===0));)e(o[r]),++r}peek(){const e=this._front,r=this._cursor;return e._elements[r]}},St=Symbol("[[AbortSteps]]"),Rt=Symbol("[[ErrorSteps]]"),Br=Symbol("[[CancelSteps]]"),Fr=Symbol("[[PullSteps]]"),Ir=Symbol("[[ReleaseSteps]]");function Tt(e,r){e._ownerReadableStream=r,r._reader=e,r._state==="readable"?Sr(e):r._state==="closed"?function(t){Sr(t),qt(t)}(e):Pt(e,r._storedError)}function Lr(e,r){return M(e._ownerReadableStream,r)}function Y(e){const r=e._ownerReadableStream;r._state==="readable"?$r(e,new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")):function(t,o){Pt(t,o)}(e,new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")),r._readableStreamController[Ir](),r._reader=void 0,e._ownerReadableStream=void 0}function rr(e){return new TypeError("Cannot "+e+" a stream using a released reader")}function Sr(e){e._closedPromise=j((r,t)=>{e._closedPromise_resolve=r,e._closedPromise_reject=t})}function Pt(e,r){Sr(e),$r(e,r)}function $r(e,r){e._closedPromise_reject!==void 0&&(qe(e._closedPromise),e._closedPromise_reject(r),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0)}function qt(e){e._closedPromise_resolve!==void 0&&(e._closedPromise_resolve(void 0),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0)}var tt=Number.isFinite||function(e){return typeof e=="number"&&isFinite(e)},Eo=Math.trunc||function(e){return e<0?Math.ceil(e):Math.floor(e)};function N(e,r){if(e!==void 0&&typeof(t=e)!="object"&&typeof t!="function")throw new TypeError(`${r} is not an object.`);var t}function $(e,r){if(typeof e!="function")throw new TypeError(`${r} is not a function.`)}function Ct(e,r){if(!function(t){return typeof t=="object"&&t!==null||typeof t=="function"}(e))throw new TypeError(`${r} is not an object.`)}function V(e,r,t){if(e===void 0)throw new TypeError(`Parameter ${r} is required in '${t}'.`)}function Rr(e,r,t){if(e===void 0)throw new TypeError(`${r} is required in '${t}'.`)}function Mr(e){return Number(e)}function ot(e){return e===0?0:e}function xr(e,r){const t=Number.MAX_SAFE_INTEGER;let o=Number(e);if(o=ot(o),!tt(o))throw new TypeError(`${r} is not a finite number`);if(o=function(i){return ot(Eo(i))}(o),o<0||o>t)throw new TypeError(`${r} is outside the accepted range of 0 to ${t}, inclusive`);return tt(o)&&o!==0?o:0}function Dr(e,r){if(!G(e))throw new TypeError(`${r} is not a ReadableStream.`)}function we(e){return new ae(e)}function Et(e,r){e._reader._readRequests.push(r)}function Nr(e,r,t){const o=e._reader._readRequests.shift();t?o._closeSteps():o._chunkSteps(r)}function lr(e){return e._reader._readRequests.length}function kt(e){const r=e._reader;return r!==void 0&&!!Z(r)}var ae=class{constructor(e){if(V(e,1,"ReadableStreamDefaultReader"),Dr(e,"First parameter"),ee(e))throw new TypeError("This stream has already been locked for exclusive reading by another reader");Tt(this,e),this._readRequests=new L}get closed(){return Z(this)?this._closedPromise:d(xe("closed"))}cancel(e=void 0){return Z(this)?this._ownerReadableStream===void 0?d(rr("cancel")):Lr(this,e):d(xe("cancel"))}read(){if(!Z(this))return d(xe("read"));if(this._ownerReadableStream===void 0)return d(rr("read from"));let e,r;const t=j((o,i)=>{e=o,r=i});return Ae(this,{_chunkSteps:o=>e({value:o,done:!1}),_closeSteps:()=>e({value:void 0,done:!0}),_errorSteps:o=>r(o)}),t}releaseLock(){if(!Z(this))throw xe("releaseLock");this._ownerReadableStream!==void 0&&function(e){Y(e);const r=new TypeError("Reader was released");jt(e,r)}(this)}};function Z(e){return!!C(e)&&!!Object.prototype.hasOwnProperty.call(e,"_readRequests")&&e instanceof ae}function Ae(e,r){const t=e._ownerReadableStream;t._disturbed=!0,t._state==="closed"?r._closeSteps():t._state==="errored"?r._errorSteps(t._storedError):t._readableStreamController[Fr](r)}function jt(e,r){const t=e._readRequests;e._readRequests=new L,t.forEach(o=>{o._errorSteps(r)})}function xe(e){return new TypeError(`ReadableStreamDefaultReader.prototype.${e} can only be used on a ReadableStreamDefaultReader`)}var hr,br,_r;function Ee(e){return e.slice()}function Ot(e,r,t,o,i){new Uint8Array(e).set(new Uint8Array(t,o,i),r)}Object.defineProperties(ae.prototype,{cancel:{enumerable:!0},read:{enumerable:!0},releaseLock:{enumerable:!0},closed:{enumerable:!0}}),v(ae.prototype.cancel,"cancel"),v(ae.prototype.read,"read"),v(ae.prototype.releaseLock,"releaseLock"),typeof Symbol.toStringTag=="symbol"&&Object.defineProperty(ae.prototype,Symbol.toStringTag,{value:"ReadableStreamDefaultReader",configurable:!0});var be=e=>(be=typeof e.transfer=="function"?r=>r.transfer():typeof structuredClone=="function"?r=>structuredClone(r,{transfer:[r]}):r=>r,be(e)),_e=e=>(_e=typeof e.detached=="boolean"?r=>r.detached:r=>r.byteLength===0,_e(e));function Wt(e,r,t){if(e.slice)return e.slice(r,t);const o=t-r,i=new ArrayBuffer(o);return Ot(i,0,e,r,o),i}function ke(e,r){const t=e[r];if(t!=null){if(typeof t!="function")throw new TypeError(`${String(r)} is not a function`);return t}}function nt(e){try{const r=e.done,t=e.value;return D(Co(t),o=>({done:r,value:o}))}catch(r){return d(r)}}var $e=(_r=(hr=Symbol.asyncIterator)!==null&&hr!==void 0?hr:(br=Symbol.for)===null||br===void 0?void 0:br.call(Symbol,"Symbol.asyncIterator"))!==null&&_r!==void 0?_r:"@@asyncIterator";function At(e,r="sync",t){if(t===void 0)if(r==="async"){if((t=ke(e,$e))===void 0)return function(i){const n={next(){let s;try{s=zt(i)}catch(a){return d(a)}return nt(s)},return(s){let a;try{const l=ke(i.iterator,"return");if(l===void 0)return g({done:!0,value:s});a=he(l,i.iterator,[s])}catch(l){return d(l)}return C(a)?nt(a):d(new TypeError("The iterator.return() method must return an object"))}};return{iterator:n,nextMethod:n.next,done:!1}}(At(e,"sync",ke(e,Symbol.iterator)))}else t=ke(e,Symbol.iterator);if(t===void 0)throw new TypeError("The object is not iterable");const o=he(t,e,[]);if(!C(o))throw new TypeError("The iterator method must return an object");return{iterator:o,nextMethod:o.next,done:!1}}function zt(e){const r=he(e.nextMethod,e.iterator,[]);if(!C(r))throw new TypeError("The iterator.next() method must return an object");return r}var Bt=class{constructor(e,r){this._ongoingPromise=void 0,this._isFinished=!1,this._reader=e,this._preventCancel=r}next(){const e=()=>this._nextSteps();return this._ongoingPromise=this._ongoingPromise?H(this._ongoingPromise,e,e):e(),this._ongoingPromise}return(e){const r=()=>this._returnSteps(e);return this._ongoingPromise?H(this._ongoingPromise,r,r):r()}_nextSteps(){if(this._isFinished)return Promise.resolve({value:void 0,done:!0});const e=this._reader;let r,t;const o=j((i,n)=>{r=i,t=n});return Ae(e,{_chunkSteps:i=>{this._ongoingPromise=void 0,fe(()=>r({value:i,done:!1}))},_closeSteps:()=>{this._ongoingPromise=void 0,this._isFinished=!0,Y(e),r({value:void 0,done:!0})},_errorSteps:i=>{this._ongoingPromise=void 0,this._isFinished=!0,Y(e),t(i)}}),o}_returnSteps(e){if(this._isFinished)return Promise.resolve({value:e,done:!0});this._isFinished=!0;const r=this._reader;if(!this._preventCancel){const t=Lr(r,e);return Y(r),H(t,()=>({value:e,done:!0}))}return Y(r),g({value:e,done:!0})}},Ft={next(){return it(this)?this._asyncIteratorImpl.next():d(at("next"))},return(e){return it(this)?this._asyncIteratorImpl.return(e):d(at("return"))},[$e](){return this}};function it(e){if(!C(e)||!Object.prototype.hasOwnProperty.call(e,"_asyncIteratorImpl"))return!1;try{return e._asyncIteratorImpl instanceof Bt}catch{return!1}}function at(e){return new TypeError(`ReadableStreamAsyncIterator.${e} can only be used on a ReadableSteamAsyncIterator`)}Object.defineProperty(Ft,$e,{enumerable:!1});var It=Number.isNaN||function(e){return e!=e};function st(e){const r=Wt(e.buffer,e.byteOffset,e.byteOffset+e.byteLength);return new Uint8Array(r)}function Tr(e){const r=e._queue.shift();return e._queueTotalSize-=r.size,e._queueTotalSize<0&&(e._queueTotalSize=0),r.value}function Qr(e,r,t){if(typeof(o=t)!="number"||It(o)||o<0||t===1/0)throw new RangeError("Size must be a finite, non-NaN, non-negative number.");var o;e._queue.push({value:r,size:t}),e._queueTotalSize+=t}function re(e){e._queue=new L,e._queueTotalSize=0}function Lt(e){return e===DataView}var ve=class{constructor(){throw new TypeError("Illegal constructor")}get view(){if(!pr(this))throw mr("view");return this._view}respond(e){if(!pr(this))throw mr("respond");if(V(e,1,"respond"),e=xr(e,"First parameter"),this._associatedReadableByteStreamController===void 0)throw new TypeError("This BYOB request has been invalidated");if(_e(this._view.buffer))throw new TypeError("The BYOB request's buffer has been detached and so cannot be used as a response");Je(this._associatedReadableByteStreamController,e)}respondWithNewView(e){if(!pr(this))throw mr("respondWithNewView");if(V(e,1,"respondWithNewView"),!ArrayBuffer.isView(e))throw new TypeError("You can only respond with array buffer views");if(this._associatedReadableByteStreamController===void 0)throw new TypeError("This BYOB request has been invalidated");if(_e(e.buffer))throw new TypeError("The given view's buffer has been detached and so cannot be used as a response");Ke(this._associatedReadableByteStreamController,e)}};Object.defineProperties(ve.prototype,{respond:{enumerable:!0},respondWithNewView:{enumerable:!0},view:{enumerable:!0}}),v(ve.prototype.respond,"respond"),v(ve.prototype.respondWithNewView,"respondWithNewView"),typeof Symbol.toStringTag=="symbol"&&Object.defineProperty(ve.prototype,Symbol.toStringTag,{value:"ReadableStreamBYOBRequest",configurable:!0});var J=class{constructor(){throw new TypeError("Illegal constructor")}get byobRequest(){if(!se(this))throw Ce("byobRequest");return Cr(this)}get desiredSize(){if(!se(this))throw Ce("desiredSize");return Ut(this)}close(){if(!se(this))throw Ce("close");if(this._closeRequested)throw new TypeError("The stream has already been closed; do not close it again!");const e=this._controlledReadableByteStream._state;if(e!=="readable")throw new TypeError(`The stream (in ${e} state) is not in the readable state and cannot be closed`);je(this)}enqueue(e){if(!se(this))throw Ce("enqueue");if(V(e,1,"enqueue"),!ArrayBuffer.isView(e))throw new TypeError("chunk must be an array buffer view");if(e.byteLength===0)throw new TypeError("chunk must have non-zero byteLength");if(e.buffer.byteLength===0)throw new TypeError("chunk's buffer must have non-zero byteLength");if(this._closeRequested)throw new TypeError("stream is closed or draining");const r=this._controlledReadableByteStream._state;if(r!=="readable")throw new TypeError(`The stream (in ${r} state) is not in the readable state and cannot be enqueued to`);Xe(this,e)}error(e=void 0){if(!se(this))throw Ce("error");I(this,e)}[Br](e){$t(this),re(this);const r=this._cancelAlgorithm(e);return ur(this),r}[Fr](e){const r=this._controlledReadableByteStream;if(this._queueTotalSize>0)return void Vt(this,e);const t=this._autoAllocateChunkSize;if(t!==void 0){let o;try{o=new ArrayBuffer(t)}catch(n){return void e._errorSteps(n)}const i={buffer:o,bufferByteLength:t,byteOffset:0,byteLength:t,bytesFilled:0,minimumFill:1,elementSize:1,viewConstructor:Uint8Array,readerType:"default"};this._pendingPullIntos.push(i)}Et(r,e),me(this)}[Ir](){if(this._pendingPullIntos.length>0){const e=this._pendingPullIntos.peek();e.readerType="none",this._pendingPullIntos=new L,this._pendingPullIntos.push(e)}}};function se(e){return!!C(e)&&!!Object.prototype.hasOwnProperty.call(e,"_controlledReadableByteStream")&&e instanceof J}function pr(e){return!!C(e)&&!!Object.prototype.hasOwnProperty.call(e,"_associatedReadableByteStreamController")&&e instanceof ve}function me(e){if(function(t){const o=t._controlledReadableByteStream;return o._state!=="readable"||t._closeRequested||!t._started?!1:!!(kt(o)&&lr(o)>0||Hr(o)&&Jt(o)>0||Ut(t)>0)}(e)){if(e._pulling)return void(e._pullAgain=!0);e._pulling=!0,F(e._pullAlgorithm(),()=>(e._pulling=!1,e._pullAgain&&(e._pullAgain=!1,me(e)),null),t=>(I(e,t),null))}}function $t(e){Yr(e),e._pendingPullIntos=new L}function Pr(e,r){let t=!1;e._state==="closed"&&(t=!0);const o=Mt(r);r.readerType==="default"?Nr(e,o,t):function(i,n,s){const a=i._reader,l=a._readIntoRequests.shift();s?l._closeSteps(n):l._chunkSteps(n)}(e,o,t)}function Mt(e){const r=e.bytesFilled,t=e.elementSize;return new e.viewConstructor(e.buffer,e.byteOffset,r/t)}function Ge(e,r,t,o){e._queue.push({buffer:r,byteOffset:t,byteLength:o}),e._queueTotalSize+=o}function xt(e,r,t,o){let i;try{i=Wt(r,t,t+o)}catch(n){throw I(e,n),n}Ge(e,i,0,o)}function Dt(e,r){r.bytesFilled>0&&xt(e,r.buffer,r.byteOffset,r.bytesFilled),Se(e)}function Nt(e,r){const t=Math.min(e._queueTotalSize,r.byteLength-r.bytesFilled),o=r.bytesFilled+t;let i=t,n=!1;const s=o-o%r.elementSize;s>=r.minimumFill&&(i=s-r.bytesFilled,n=!0);const a=e._queue;for(;i>0;){const l=a.peek(),u=Math.min(i,l.byteLength),h=r.byteOffset+r.bytesFilled;Ot(r.buffer,h,l.buffer,l.byteOffset,u),l.byteLength===u?a.shift():(l.byteOffset+=u,l.byteLength-=u),e._queueTotalSize-=u,Qt(e,u,r),i-=u}return n}function Qt(e,r,t){t.bytesFilled+=r}function Yt(e){e._queueTotalSize===0&&e._closeRequested?(ur(e),Me(e._controlledReadableByteStream)):me(e)}function Yr(e){e._byobRequest!==null&&(e._byobRequest._associatedReadableByteStreamController=void 0,e._byobRequest._view=null,e._byobRequest=null)}function qr(e){for(;e._pendingPullIntos.length>0;){if(e._queueTotalSize===0)return;const r=e._pendingPullIntos.peek();Nt(e,r)&&(Se(e),Pr(e._controlledReadableByteStream,r))}}function ko(e,r,t,o){const i=e._controlledReadableByteStream,n=r.constructor,s=function(f){return Lt(f)?1:f.BYTES_PER_ELEMENT}(n),{byteOffset:a,byteLength:l}=r,u=t*s;let h;try{h=be(r.buffer)}catch(f){return void o._errorSteps(f)}const c={buffer:h,bufferByteLength:h.byteLength,byteOffset:a,byteLength:l,bytesFilled:0,minimumFill:u,elementSize:s,viewConstructor:n,readerType:"byob"};if(e._pendingPullIntos.length>0)return e._pendingPullIntos.push(c),void lt(i,o);if(i._state!=="closed"){if(e._queueTotalSize>0){if(Nt(e,c)){const f=Mt(c);return Yt(e),void o._chunkSteps(f)}if(e._closeRequested){const f=new TypeError("Insufficient bytes to fill elements in the given buffer");return I(e,f),void o._errorSteps(f)}}e._pendingPullIntos.push(c),lt(i,o),me(e)}else{const f=new n(c.buffer,c.byteOffset,0);o._closeSteps(f)}}function Ht(e,r){const t=e._pendingPullIntos.peek();Yr(e),e._controlledReadableByteStream._state==="closed"?function(o,i){i.readerType==="none"&&Se(o);const n=o._controlledReadableByteStream;if(Hr(n))for(;Jt(n)>0;)Pr(n,Se(o))}(e,t):function(o,i,n){if(Qt(0,i,n),n.readerType==="none")return Dt(o,n),void qr(o);if(n.bytesFilled<n.minimumFill)return;Se(o);const s=n.bytesFilled%n.elementSize;if(s>0){const a=n.byteOffset+n.bytesFilled;xt(o,n.buffer,a-s,s)}n.bytesFilled-=s,Pr(o._controlledReadableByteStream,n),qr(o)}(e,r,t),me(e)}function Se(e){return e._pendingPullIntos.shift()}function ur(e){e._pullAlgorithm=void 0,e._cancelAlgorithm=void 0}function je(e){const r=e._controlledReadableByteStream;if(!e._closeRequested&&r._state==="readable")if(e._queueTotalSize>0)e._closeRequested=!0;else{if(e._pendingPullIntos.length>0){const t=e._pendingPullIntos.peek();if(t.bytesFilled%t.elementSize!=0){const o=new TypeError("Insufficient bytes to fill elements in the given buffer");throw I(e,o),o}}ur(e),Me(r)}}function Xe(e,r){const t=e._controlledReadableByteStream;if(e._closeRequested||t._state!=="readable")return;const{buffer:o,byteOffset:i,byteLength:n}=r;if(_e(o))throw new TypeError("chunk's buffer is detached and so cannot be enqueued");const s=be(o);if(e._pendingPullIntos.length>0){const a=e._pendingPullIntos.peek();if(_e(a.buffer))throw new TypeError("The BYOB request's buffer has been detached and so cannot be filled with an enqueued chunk");Yr(e),a.buffer=be(a.buffer),a.readerType==="none"&&Dt(e,a)}kt(t)?(function(a){const l=a._controlledReadableByteStream._reader;for(;l._readRequests.length>0;){if(a._queueTotalSize===0)return;Vt(a,l._readRequests.shift())}}(e),lr(t)===0?Ge(e,s,i,n):(e._pendingPullIntos.length>0&&Se(e),Nr(t,new Uint8Array(s,i,n),!1))):Hr(t)?(Ge(e,s,i,n),qr(e)):Ge(e,s,i,n),me(e)}function I(e,r){const t=e._controlledReadableByteStream;t._state==="readable"&&($t(e),re(e),ur(e),yo(t,r))}function Vt(e,r){const t=e._queue.shift();e._queueTotalSize-=t.byteLength,Yt(e);const o=new Uint8Array(t.buffer,t.byteOffset,t.byteLength);r._chunkSteps(o)}function Cr(e){if(e._byobRequest===null&&e._pendingPullIntos.length>0){const r=e._pendingPullIntos.peek(),t=new Uint8Array(r.buffer,r.byteOffset+r.bytesFilled,r.byteLength-r.bytesFilled),o=Object.create(ve.prototype);(function(i,n,s){i._associatedReadableByteStreamController=n,i._view=s})(o,e,t),e._byobRequest=o}return e._byobRequest}function Ut(e){const r=e._controlledReadableByteStream._state;return r==="errored"?null:r==="closed"?0:e._strategyHWM-e._queueTotalSize}function Je(e,r){const t=e._pendingPullIntos.peek();if(e._controlledReadableByteStream._state==="closed"){if(r!==0)throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream")}else{if(r===0)throw new TypeError("bytesWritten must be greater than 0 when calling respond() on a readable stream");if(t.bytesFilled+r>t.byteLength)throw new RangeError("bytesWritten out of range")}t.buffer=be(t.buffer),Ht(e,r)}function Ke(e,r){const t=e._pendingPullIntos.peek();if(e._controlledReadableByteStream._state==="closed"){if(r.byteLength!==0)throw new TypeError("The view's length must be 0 when calling respondWithNewView() on a closed stream")}else if(r.byteLength===0)throw new TypeError("The view's length must be greater than 0 when calling respondWithNewView() on a readable stream");if(t.byteOffset+t.bytesFilled!==r.byteOffset)throw new RangeError("The region specified by view does not match byobRequest");if(t.bufferByteLength!==r.buffer.byteLength)throw new RangeError("The buffer of view has different capacity than byobRequest");if(t.bytesFilled+r.byteLength>t.byteLength)throw new RangeError("The region specified by view is larger than byobRequest");const o=r.byteLength;t.buffer=be(r.buffer),Ht(e,o)}function Gt(e,r,t,o,i,n,s){r._controlledReadableByteStream=e,r._pullAgain=!1,r._pulling=!1,r._byobRequest=null,r._queue=r._queueTotalSize=void 0,re(r),r._closeRequested=!1,r._started=!1,r._strategyHWM=n,r._pullAlgorithm=o,r._cancelAlgorithm=i,r._autoAllocateChunkSize=s,r._pendingPullIntos=new L,e._readableStreamController=r,F(g(t()),()=>(r._started=!0,me(r),null),a=>(I(r,a),null))}function mr(e){return new TypeError(`ReadableStreamBYOBRequest.prototype.${e} can only be used on a ReadableStreamBYOBRequest`)}function Ce(e){return new TypeError(`ReadableByteStreamController.prototype.${e} can only be used on a ReadableByteStreamController`)}function jo(e,r){if((e=`${e}`)!="byob")throw new TypeError(`${r} '${e}' is not a valid enumeration value for ReadableStreamReaderMode`);return e}function Xt(e){return new le(e)}function lt(e,r){e._reader._readIntoRequests.push(r)}function Jt(e){return e._reader._readIntoRequests.length}function Hr(e){const r=e._reader;return r!==void 0&&!!de(r)}Object.defineProperties(J.prototype,{close:{enumerable:!0},enqueue:{enumerable:!0},error:{enumerable:!0},byobRequest:{enumerable:!0},desiredSize:{enumerable:!0}}),v(J.prototype.close,"close"),v(J.prototype.enqueue,"enqueue"),v(J.prototype.error,"error"),typeof Symbol.toStringTag=="symbol"&&Object.defineProperty(J.prototype,Symbol.toStringTag,{value:"ReadableByteStreamController",configurable:!0});var le=class{constructor(e){if(V(e,1,"ReadableStreamBYOBReader"),Dr(e,"First parameter"),ee(e))throw new TypeError("This stream has already been locked for exclusive reading by another reader");if(!se(e._readableStreamController))throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");Tt(this,e),this._readIntoRequests=new L}get closed(){return de(this)?this._closedPromise:d(De("closed"))}cancel(e=void 0){return de(this)?this._ownerReadableStream===void 0?d(rr("cancel")):Lr(this,e):d(De("cancel"))}read(e,r={}){if(!de(this))return d(De("read"));if(!ArrayBuffer.isView(e))return d(new TypeError("view must be an array buffer view"));if(e.byteLength===0)return d(new TypeError("view must have non-zero byteLength"));if(e.buffer.byteLength===0)return d(new TypeError("view's buffer must have non-zero byteLength"));if(_e(e.buffer))return d(new TypeError("view's buffer has been detached"));let t;try{t=function(a,l){var u;return N(a,l),{min:xr((u=a==null?void 0:a.min)!==null&&u!==void 0?u:1,`${l} has member 'min' that`)}}(r,"options")}catch(a){return d(a)}const o=t.min;if(o===0)return d(new TypeError("options.min must be greater than 0"));if(function(a){return Lt(a.constructor)}(e)){if(o>e.byteLength)return d(new RangeError("options.min must be less than or equal to view's byteLength"))}else if(o>e.length)return d(new RangeError("options.min must be less than or equal to view's length"));if(this._ownerReadableStream===void 0)return d(rr("read from"));let i,n;const s=j((a,l)=>{i=a,n=l});return Kt(this,e,o,{_chunkSteps:a=>i({value:a,done:!1}),_closeSteps:a=>i({value:a,done:!0}),_errorSteps:a=>n(a)}),s}releaseLock(){if(!de(this))throw De("releaseLock");this._ownerReadableStream!==void 0&&function(e){Y(e);const r=new TypeError("Reader was released");Zt(e,r)}(this)}};function de(e){return!!C(e)&&!!Object.prototype.hasOwnProperty.call(e,"_readIntoRequests")&&e instanceof le}function Kt(e,r,t,o){const i=e._ownerReadableStream;i._disturbed=!0,i._state==="errored"?o._errorSteps(i._storedError):ko(i._readableStreamController,r,t,o)}function Zt(e,r){const t=e._readIntoRequests;e._readIntoRequests=new L,t.forEach(o=>{o._errorSteps(r)})}function De(e){return new TypeError(`ReadableStreamBYOBReader.prototype.${e} can only be used on a ReadableStreamBYOBReader`)}function ze(e,r){const{highWaterMark:t}=e;if(t===void 0)return r;if(It(t)||t<0)throw new RangeError("Invalid highWaterMark");return t}function tr(e){const{size:r}=e;return r||(()=>1)}function or(e,r){N(e,r);const t=e==null?void 0:e.highWaterMark,o=e==null?void 0:e.size;return{highWaterMark:t===void 0?void 0:Mr(t),size:o===void 0?void 0:Oo(o,`${r} has member 'size' that`)}}function Oo(e,r){return $(e,r),t=>Mr(e(t))}function Wo(e,r,t){return $(e,t),o=>U(e,r,[o])}function Ao(e,r,t){return $(e,t),()=>U(e,r,[])}function zo(e,r,t){return $(e,t),o=>he(e,r,[o])}function Bo(e,r,t){return $(e,t),(o,i)=>U(e,r,[o,i])}function eo(e,r){if(!ge(e))throw new TypeError(`${r} is not a WritableStream.`)}Object.defineProperties(le.prototype,{cancel:{enumerable:!0},read:{enumerable:!0},releaseLock:{enumerable:!0},closed:{enumerable:!0}}),v(le.prototype.cancel,"cancel"),v(le.prototype.read,"read"),v(le.prototype.releaseLock,"releaseLock"),typeof Symbol.toStringTag=="symbol"&&Object.defineProperty(le.prototype,Symbol.toStringTag,{value:"ReadableStreamBYOBReader",configurable:!0});var Fo=typeof AbortController=="function",ue=class{constructor(e={},r={}){e===void 0?e=null:Ct(e,"First parameter");const t=or(r,"Second parameter"),o=function(n,s){N(n,s);const a=n==null?void 0:n.abort,l=n==null?void 0:n.close,u=n==null?void 0:n.start,h=n==null?void 0:n.type,c=n==null?void 0:n.write;return{abort:a===void 0?void 0:Wo(a,n,`${s} has member 'abort' that`),close:l===void 0?void 0:Ao(l,n,`${s} has member 'close' that`),start:u===void 0?void 0:zo(u,n,`${s} has member 'start' that`),write:c===void 0?void 0:Bo(c,n,`${s} has member 'write' that`),type:h}}(e,"First parameter");if(to(this),o.type!==void 0)throw new RangeError("Invalid type is specified");const i=tr(t);(function(n,s,a,l){const u=Object.create(Be.prototype);let h,c,f,y;h=s.start!==void 0?()=>s.start(u):()=>{},c=s.write!==void 0?E=>s.write(E,u):()=>g(void 0),f=s.close!==void 0?()=>s.close():()=>g(void 0),y=s.abort!==void 0?E=>s.abort(E):()=>g(void 0),uo(n,u,h,c,f,y,a,l)})(this,o,ze(t,1),i)}get locked(){if(!ge(this))throw Qe("locked");return Re(this)}abort(e=void 0){return ge(this)?Re(this)?d(new TypeError("Cannot abort a stream that already has a writer")):nr(this,e):d(Qe("abort"))}close(){return ge(this)?Re(this)?d(new TypeError("Cannot close a stream that already has a writer")):Q(this)?d(new TypeError("Cannot close an already-closing stream")):oo(this):d(Qe("close"))}getWriter(){if(!ge(this))throw Qe("getWriter");return ro(this)}};function ro(e){return new X(e)}function to(e){e._state="writable",e._storedError=void 0,e._writer=void 0,e._writableStreamController=void 0,e._writeRequests=new L,e._inFlightWriteRequest=void 0,e._closeRequest=void 0,e._inFlightCloseRequest=void 0,e._pendingAbortRequest=void 0,e._backpressure=!1}function ge(e){return!!C(e)&&!!Object.prototype.hasOwnProperty.call(e,"_writableStreamController")&&e instanceof ue}function Re(e){return e._writer!==void 0}function nr(e,r){var t;if(e._state==="closed"||e._state==="errored")return g(void 0);e._writableStreamController._abortReason=r,(t=e._writableStreamController._abortController)===null||t===void 0||t.abort(r);const o=e._state;if(o==="closed"||o==="errored")return g(void 0);if(e._pendingAbortRequest!==void 0)return e._pendingAbortRequest._promise;let i=!1;o==="erroring"&&(i=!0,r=void 0);const n=j((s,a)=>{e._pendingAbortRequest={_promise:void 0,_resolve:s,_reject:a,_reason:r,_wasAlreadyErroring:i}});return e._pendingAbortRequest._promise=n,i||Vr(e,r),n}function oo(e){const r=e._state;if(r==="closed"||r==="errored")return d(new TypeError(`The stream (in ${r} state) is not in the writable state and cannot be closed`));const t=j((n,s)=>{const a={_resolve:n,_reject:s};e._closeRequest=a}),o=e._writer;var i;return o!==void 0&&e._backpressure&&r==="writable"&&Kr(o),Qr(i=e._writableStreamController,lo,0),cr(i),t}function Er(e,r){e._state!=="writable"?Ur(e):Vr(e,r)}function Vr(e,r){const t=e._writableStreamController;e._state="erroring",e._storedError=r;const o=e._writer;o!==void 0&&io(o,r),!function(i){return!(i._inFlightWriteRequest===void 0&&i._inFlightCloseRequest===void 0)}(e)&&t._started&&Ur(e)}function Ur(e){e._state="errored",e._writableStreamController[Rt]();const r=e._storedError;if(e._writeRequests.forEach(o=>{o._reject(r)}),e._writeRequests=new L,e._pendingAbortRequest===void 0)return void Ne(e);const t=e._pendingAbortRequest;if(e._pendingAbortRequest=void 0,t._wasAlreadyErroring)return t._reject(r),void Ne(e);F(e._writableStreamController[St](t._reason),()=>(t._resolve(),Ne(e),null),o=>(t._reject(o),Ne(e),null))}function Q(e){return e._closeRequest!==void 0||e._inFlightCloseRequest!==void 0}function Ne(e){e._closeRequest!==void 0&&(e._closeRequest._reject(e._storedError),e._closeRequest=void 0);const r=e._writer;r!==void 0&&Jr(r,e._storedError)}function Gr(e,r){const t=e._writer;t!==void 0&&r!==e._backpressure&&(r?function(o){dr(o)}(t):Kr(t)),e._backpressure=r}Object.defineProperties(ue.prototype,{abort:{enumerable:!0},close:{enumerable:!0},getWriter:{enumerable:!0},locked:{enumerable:!0}}),v(ue.prototype.abort,"abort"),v(ue.prototype.close,"close"),v(ue.prototype.getWriter,"getWriter"),typeof Symbol.toStringTag=="symbol"&&Object.defineProperty(ue.prototype,Symbol.toStringTag,{value:"WritableStream",configurable:!0});var X=class{constructor(e){if(V(e,1,"WritableStreamDefaultWriter"),eo(e,"First parameter"),Re(e))throw new TypeError("This stream has already been locked for exclusive writing by another writer");this._ownerWritableStream=e,e._writer=this;const r=e._state;if(r==="writable")!Q(e)&&e._backpressure?dr(this):ut(this),Ze(this);else if(r==="erroring")kr(this,e._storedError),Ze(this);else if(r==="closed")ut(this),Ze(t=this),bo(t);else{const o=e._storedError;kr(this,o),ho(this,o)}var t}get closed(){return oe(this)?this._closedPromise:d(ne("closed"))}get desiredSize(){if(!oe(this))throw ne("desiredSize");if(this._ownerWritableStream===void 0)throw Oe("desiredSize");return function(e){const r=e._ownerWritableStream,t=r._state;return t==="errored"||t==="erroring"?null:t==="closed"?0:co(r._writableStreamController)}(this)}get ready(){return oe(this)?this._readyPromise:d(ne("ready"))}abort(e=void 0){return oe(this)?this._ownerWritableStream===void 0?d(Oe("abort")):function(r,t){return nr(r._ownerWritableStream,t)}(this,e):d(ne("abort"))}close(){if(!oe(this))return d(ne("close"));const e=this._ownerWritableStream;return e===void 0?d(Oe("close")):Q(e)?d(new TypeError("Cannot close an already-closing stream")):no(this)}releaseLock(){if(!oe(this))throw ne("releaseLock");this._ownerWritableStream!==void 0&&ao(this)}write(e=void 0){return oe(this)?this._ownerWritableStream===void 0?d(Oe("write to")):so(this,e):d(ne("write"))}};function oe(e){return!!C(e)&&!!Object.prototype.hasOwnProperty.call(e,"_ownerWritableStream")&&e instanceof X}function no(e){return oo(e._ownerWritableStream)}function Io(e,r){e._closedPromiseState==="pending"?Jr(e,r):function(t,o){ho(t,o)}(e,r)}function io(e,r){e._readyPromiseState==="pending"?_o(e,r):function(t,o){kr(t,o)}(e,r)}function ao(e){const r=e._ownerWritableStream,t=new TypeError("Writer was released and can no longer be used to monitor the stream's closedness");io(e,t),Io(e,t),r._writer=void 0,e._ownerWritableStream=void 0}function so(e,r){const t=e._ownerWritableStream,o=t._writableStreamController,i=function(a,l){try{return a._strategySizeAlgorithm(l)}catch(u){return Fe(a,u),1}}(o,r);if(t!==e._ownerWritableStream)return d(Oe("write to"));const n=t._state;if(n==="errored")return d(t._storedError);if(Q(t)||n==="closed")return d(new TypeError("The stream is closing or closed and cannot be written to"));if(n==="erroring")return d(t._storedError);const s=function(a){return j((l,u)=>{const h={_resolve:l,_reject:u};a._writeRequests.push(h)})}(t);return function(a,l,u){try{Qr(a,l,u)}catch(c){return void Fe(a,c)}const h=a._controlledWritableStream;!Q(h)&&h._state==="writable"&&Gr(h,Xr(a)),cr(a)}(o,r,i),s}Object.defineProperties(X.prototype,{abort:{enumerable:!0},close:{enumerable:!0},releaseLock:{enumerable:!0},write:{enumerable:!0},closed:{enumerable:!0},desiredSize:{enumerable:!0},ready:{enumerable:!0}}),v(X.prototype.abort,"abort"),v(X.prototype.close,"close"),v(X.prototype.releaseLock,"releaseLock"),v(X.prototype.write,"write"),typeof Symbol.toStringTag=="symbol"&&Object.defineProperty(X.prototype,Symbol.toStringTag,{value:"WritableStreamDefaultWriter",configurable:!0});var lo={},Be=class{constructor(){throw new TypeError("Illegal constructor")}get abortReason(){if(!yr(this))throw vr("abortReason");return this._abortReason}get signal(){if(!yr(this))throw vr("signal");if(this._abortController===void 0)throw new TypeError("WritableStreamDefaultController.prototype.signal is not supported");return this._abortController.signal}error(e=void 0){if(!yr(this))throw vr("error");this._controlledWritableStream._state==="writable"&&fo(this,e)}[St](e){const r=this._abortAlgorithm(e);return ir(this),r}[Rt](){re(this)}};function yr(e){return!!C(e)&&!!Object.prototype.hasOwnProperty.call(e,"_controlledWritableStream")&&e instanceof Be}function uo(e,r,t,o,i,n,s,a){r._controlledWritableStream=e,e._writableStreamController=r,r._queue=void 0,r._queueTotalSize=void 0,re(r),r._abortReason=void 0,r._abortController=function(){if(Fo)return new AbortController}(),r._started=!1,r._strategySizeAlgorithm=a,r._strategyHWM=s,r._writeAlgorithm=o,r._closeAlgorithm=i,r._abortAlgorithm=n;const l=Xr(r);Gr(e,l),F(g(t()),()=>(r._started=!0,cr(r),null),u=>(r._started=!0,Er(e,u),null))}function ir(e){e._writeAlgorithm=void 0,e._closeAlgorithm=void 0,e._abortAlgorithm=void 0,e._strategySizeAlgorithm=void 0}function co(e){return e._strategyHWM-e._queueTotalSize}function cr(e){const r=e._controlledWritableStream;if(!e._started||r._inFlightWriteRequest!==void 0)return;if(r._state==="erroring")return void Ur(r);if(e._queue.length===0)return;const t=e._queue.peek().value;t===lo?function(o){const i=o._controlledWritableStream;(function(s){s._inFlightCloseRequest=s._closeRequest,s._closeRequest=void 0})(i),Tr(o);const n=o._closeAlgorithm();ir(o),F(n,()=>(function(s){s._inFlightCloseRequest._resolve(void 0),s._inFlightCloseRequest=void 0,s._state==="erroring"&&(s._storedError=void 0,s._pendingAbortRequest!==void 0&&(s._pendingAbortRequest._resolve(),s._pendingAbortRequest=void 0)),s._state="closed";const a=s._writer;a!==void 0&&bo(a)}(i),null),s=>(function(a,l){a._inFlightCloseRequest._reject(l),a._inFlightCloseRequest=void 0,a._pendingAbortRequest!==void 0&&(a._pendingAbortRequest._reject(l),a._pendingAbortRequest=void 0),Er(a,l)}(i,s),null))}(e):function(o,i){const n=o._controlledWritableStream;(function(a){a._inFlightWriteRequest=a._writeRequests.shift()})(n);const s=o._writeAlgorithm(i);F(s,()=>{(function(l){l._inFlightWriteRequest._resolve(void 0),l._inFlightWriteRequest=void 0})(n);const a=n._state;if(Tr(o),!Q(n)&&a==="writable"){const l=Xr(o);Gr(n,l)}return cr(o),null},a=>(n._state==="writable"&&ir(o),function(l,u){l._inFlightWriteRequest._reject(u),l._inFlightWriteRequest=void 0,Er(l,u)}(n,a),null))}(e,t)}function Fe(e,r){e._controlledWritableStream._state==="writable"&&fo(e,r)}function Xr(e){return co(e)<=0}function fo(e,r){const t=e._controlledWritableStream;ir(e),Vr(t,r)}function Qe(e){return new TypeError(`WritableStream.prototype.${e} can only be used on a WritableStream`)}function vr(e){return new TypeError(`WritableStreamDefaultController.prototype.${e} can only be used on a WritableStreamDefaultController`)}function ne(e){return new TypeError(`WritableStreamDefaultWriter.prototype.${e} can only be used on a WritableStreamDefaultWriter`)}function Oe(e){return new TypeError("Cannot "+e+" a stream using a released writer")}function Ze(e){e._closedPromise=j((r,t)=>{e._closedPromise_resolve=r,e._closedPromise_reject=t,e._closedPromiseState="pending"})}function ho(e,r){Ze(e),Jr(e,r)}function Jr(e,r){e._closedPromise_reject!==void 0&&(qe(e._closedPromise),e._closedPromise_reject(r),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0,e._closedPromiseState="rejected")}function bo(e){e._closedPromise_resolve!==void 0&&(e._closedPromise_resolve(void 0),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0,e._closedPromiseState="resolved")}function dr(e){e._readyPromise=j((r,t)=>{e._readyPromise_resolve=r,e._readyPromise_reject=t}),e._readyPromiseState="pending"}function kr(e,r){dr(e),_o(e,r)}function ut(e){dr(e),Kr(e)}function _o(e,r){e._readyPromise_reject!==void 0&&(qe(e._readyPromise),e._readyPromise_reject(r),e._readyPromise_resolve=void 0,e._readyPromise_reject=void 0,e._readyPromiseState="rejected")}function Kr(e){e._readyPromise_resolve!==void 0&&(e._readyPromise_resolve(void 0),e._readyPromise_resolve=void 0,e._readyPromise_reject=void 0,e._readyPromiseState="fulfilled")}Object.defineProperties(Be.prototype,{abortReason:{enumerable:!0},signal:{enumerable:!0},error:{enumerable:!0}}),typeof Symbol.toStringTag=="symbol"&&Object.defineProperty(Be.prototype,Symbol.toStringTag,{value:"WritableStreamDefaultController",configurable:!0});var ct=typeof globalThis<"u"?globalThis:typeof self<"u"?self:typeof global<"u"?global:void 0,Lo=function(){const e=ct==null?void 0:ct.DOMException;return function(r){if(typeof r!="function"&&typeof r!="object"||r.name!=="DOMException")return!1;try{return new r,!0}catch{return!1}}(e)?e:void 0}()||function(){const e=function(r,t){this.message=r||"",this.name=t||"Error",Error.captureStackTrace&&Error.captureStackTrace(this,this.constructor)};return v(e,"DOMException"),e.prototype=Object.create(Error.prototype),Object.defineProperty(e.prototype,"constructor",{value:e,writable:!0,configurable:!0}),e}();function dt(e,r,t,o,i,n){const s=we(e),a=ro(r);e._disturbed=!0;let l=!1,u=g(void 0);return j((h,c)=>{let f;if(n!==void 0){if(f=()=>{const p=n.reason!==void 0?n.reason:new Lo("Aborted","AbortError"),P=[];o||P.push(()=>r._state==="writable"?nr(r,p):g(void 0)),i||P.push(()=>e._state==="readable"?M(e,p):g(void 0)),R(()=>Promise.all(P.map(_=>_())),!0,p)},n.aborted)return void f();n.addEventListener("abort",f)}var y,E,O;if(q(e,s._closedPromise,p=>(o?T(!0,p):R(()=>nr(r,p),!0,p),null)),q(r,a._closedPromise,p=>(i?T(!0,p):R(()=>M(e,p),!0,p),null)),y=e,E=s._closedPromise,O=()=>(t?T():R(()=>function(p){const P=p._ownerWritableStream,_=P._state;return Q(P)||_==="closed"?g(void 0):_==="errored"?d(P._storedError):no(p)}(a)),null),y._state==="closed"?O():fr(E,O),Q(r)||r._state==="closed"){const p=new TypeError("the destination writable stream closed before all data could be piped to it");i?T(!0,p):R(()=>M(e,p),!0,p)}function W(){const p=u;return D(u,()=>p!==u?W():void 0)}function q(p,P,_){p._state==="errored"?_(p._storedError):wr(P,_)}function R(p,P,_){function b(){return F(p(),()=>A(P,_),w=>A(!0,w)),null}l||(l=!0,r._state!=="writable"||Q(r)?b():fr(W(),b))}function T(p,P){l||(l=!0,r._state!=="writable"||Q(r)?A(p,P):fr(W(),()=>A(p,P)))}function A(p,P){return ao(a),Y(s),n!==void 0&&n.removeEventListener("abort",f),p?c(P):h(void 0),null}qe(j((p,P)=>{(function _(b){b?p():D(l?g(!0):D(a._readyPromise,()=>j((w,m)=>{Ae(s,{_chunkSteps:S=>{u=D(so(a,S),void 0,We),w(!1)},_closeSteps:()=>w(!0),_errorSteps:m})})),_,P)})(!1)}))})}var K=class{constructor(){throw new TypeError("Illegal constructor")}get desiredSize(){if(!Ye(this))throw He("desiredSize");return Zr(this)}close(){if(!Ye(this))throw He("close");if(!Pe(this))throw new TypeError("The stream is not in a state that permits close");pe(this)}enqueue(e=void 0){if(!Ye(this))throw He("enqueue");if(!Pe(this))throw new TypeError("The stream is not in a state that permits enqueue");return Te(this,e)}error(e=void 0){if(!Ye(this))throw He("error");x(this,e)}[Br](e){re(this);const r=this._cancelAlgorithm(e);return ar(this),r}[Fr](e){const r=this._controlledReadableStream;if(this._queue.length>0){const t=Tr(this);this._closeRequested&&this._queue.length===0?(ar(this),Me(r)):Ie(this),e._chunkSteps(t)}else Et(r,e),Ie(this)}[Ir](){}};function Ye(e){return!!C(e)&&!!Object.prototype.hasOwnProperty.call(e,"_controlledReadableStream")&&e instanceof K}function Ie(e){if(po(e)){if(e._pulling)return void(e._pullAgain=!0);e._pulling=!0,F(e._pullAlgorithm(),()=>(e._pulling=!1,e._pullAgain&&(e._pullAgain=!1,Ie(e)),null),r=>(x(e,r),null))}}function po(e){const r=e._controlledReadableStream;return!Pe(e)||!e._started?!1:ee(r)&&lr(r)>0?!0:Zr(e)>0}function ar(e){e._pullAlgorithm=void 0,e._cancelAlgorithm=void 0,e._strategySizeAlgorithm=void 0}function pe(e){if(!Pe(e))return;const r=e._controlledReadableStream;e._closeRequested=!0,e._queue.length===0&&(ar(e),Me(r))}function Te(e,r){if(!Pe(e))return;const t=e._controlledReadableStream;if(ee(t)&&lr(t)>0)Nr(t,r,!1);else{let o;try{o=e._strategySizeAlgorithm(r)}catch(i){throw x(e,i),i}try{Qr(e,r,o)}catch(i){throw x(e,i),i}}Ie(e)}function x(e,r){const t=e._controlledReadableStream;t._state==="readable"&&(re(e),ar(e),yo(t,r))}function Zr(e){const r=e._controlledReadableStream._state;return r==="errored"?null:r==="closed"?0:e._strategyHWM-e._queueTotalSize}function Pe(e){const r=e._controlledReadableStream._state;return!e._closeRequested&&r==="readable"}function mo(e,r,t,o,i,n,s){r._controlledReadableStream=e,r._queue=void 0,r._queueTotalSize=void 0,re(r),r._started=!1,r._closeRequested=!1,r._pullAgain=!1,r._pulling=!1,r._strategySizeAlgorithm=s,r._strategyHWM=n,r._pullAlgorithm=o,r._cancelAlgorithm=i,e._readableStreamController=r,F(g(t()),()=>(r._started=!0,Ie(r),null),a=>(x(r,a),null))}function He(e){return new TypeError(`ReadableStreamDefaultController.prototype.${e} can only be used on a ReadableStreamDefaultController`)}function $o(e,r){return se(e._readableStreamController)?function(t){let o,i,n,s,a,l=we(t),u=!1,h=!1,c=!1,f=!1,y=!1;const E=j(_=>{a=_});function O(_){wr(_._closedPromise,b=>(_!==l||(I(n._readableStreamController,b),I(s._readableStreamController,b),f&&y||a(void 0)),null))}function W(){de(l)&&(Y(l),l=we(t),O(l)),Ae(l,{_chunkSteps:_=>{fe(()=>{h=!1,c=!1;const b=_;let w=_;if(!f&&!y)try{w=st(_)}catch(m){return I(n._readableStreamController,m),I(s._readableStreamController,m),void a(M(t,m))}f||Xe(n._readableStreamController,b),y||Xe(s._readableStreamController,w),u=!1,h?R():c&&T()})},_closeSteps:()=>{u=!1,f||je(n._readableStreamController),y||je(s._readableStreamController),n._readableStreamController._pendingPullIntos.length>0&&Je(n._readableStreamController,0),s._readableStreamController._pendingPullIntos.length>0&&Je(s._readableStreamController,0),f&&y||a(void 0)},_errorSteps:()=>{u=!1}})}function q(_,b){Z(l)&&(Y(l),l=Xt(t),O(l));const w=b?s:n,m=b?n:s;Kt(l,_,1,{_chunkSteps:S=>{fe(()=>{h=!1,c=!1;const B=b?y:f;if(b?f:y)B||Ke(w._readableStreamController,S);else{let k;try{k=st(S)}catch(te){return I(w._readableStreamController,te),I(m._readableStreamController,te),void a(M(t,te))}B||Ke(w._readableStreamController,S),Xe(m._readableStreamController,k)}u=!1,h?R():c&&T()})},_closeSteps:S=>{u=!1;const B=b?y:f,k=b?f:y;B||je(w._readableStreamController),k||je(m._readableStreamController),S!==void 0&&(B||Ke(w._readableStreamController,S),!k&&m._readableStreamController._pendingPullIntos.length>0&&Je(m._readableStreamController,0)),B&&k||a(void 0)},_errorSteps:()=>{u=!1}})}function R(){if(u)return h=!0,g(void 0);u=!0;const _=Cr(n._readableStreamController);return _===null?W():q(_._view,!1),g(void 0)}function T(){if(u)return c=!0,g(void 0);u=!0;const _=Cr(s._readableStreamController);return _===null?W():q(_._view,!0),g(void 0)}function A(_){if(f=!0,o=_,y){const b=Ee([o,i]),w=M(t,b);a(w)}return E}function p(_){if(y=!0,i=_,f){const b=Ee([o,i]),w=M(t,b);a(w)}return E}function P(){}return n=ht(P,R,A),s=ht(P,T,p),O(l),[n,s]}(e):function(t,o){const i=we(t);let n,s,a,l,u,h=!1,c=!1,f=!1,y=!1;const E=j(T=>{u=T});function O(){return h?(c=!0,g(void 0)):(h=!0,Ae(i,{_chunkSteps:T=>{fe(()=>{c=!1;const A=T,p=T;f||Te(a._readableStreamController,A),y||Te(l._readableStreamController,p),h=!1,c&&O()})},_closeSteps:()=>{h=!1,f||pe(a._readableStreamController),y||pe(l._readableStreamController),f&&y||u(void 0)},_errorSteps:()=>{h=!1}}),g(void 0))}function W(T){if(f=!0,n=T,y){const A=Ee([n,s]),p=M(t,A);u(p)}return E}function q(T){if(y=!0,s=T,f){const A=Ee([n,s]),p=M(t,A);u(p)}return E}function R(){}return a=Le(R,O,W),l=Le(R,O,q),wr(i._closedPromise,T=>(x(a._readableStreamController,T),x(l._readableStreamController,T),f&&y||u(void 0),null)),[a,l]}(e)}function Mo(e){return C(r=e)&&r.getReader!==void 0?function(t){let o;function i(){let s;try{s=t.read()}catch(a){return d(a)}return H(s,a=>{if(!C(a))throw new TypeError("The promise returned by the reader.read() method must fulfill with an object");if(a.done)pe(o._readableStreamController);else{const l=a.value;Te(o._readableStreamController,l)}})}function n(s){try{return g(t.cancel(s))}catch(a){return d(a)}}return o=Le(We,i,n,0),o}(e.getReader()):function(t){let o;const i=At(t,"async");function n(){let a;try{a=zt(i)}catch(l){return d(l)}return H(g(a),l=>{if(!C(l))throw new TypeError("The promise returned by the iterator.next() method must fulfill with an object");if(l.done)pe(o._readableStreamController);else{const u=l.value;Te(o._readableStreamController,u)}})}function s(a){const l=i.iterator;let u;try{u=ke(l,"return")}catch(h){return d(h)}return u===void 0?g(void 0):H(U(u,l,[a]),h=>{if(!C(h))throw new TypeError("The promise returned by the iterator.return() method must fulfill with an object")})}return o=Le(We,n,s,0),o}(e);var r}function xo(e,r,t){return $(e,t),o=>U(e,r,[o])}function Do(e,r,t){return $(e,t),o=>U(e,r,[o])}function No(e,r,t){return $(e,t),o=>he(e,r,[o])}function Qo(e,r){if((e=`${e}`)!="bytes")throw new TypeError(`${r} '${e}' is not a valid enumeration value for ReadableStreamType`);return e}function ft(e,r){N(e,r);const t=e==null?void 0:e.preventAbort,o=e==null?void 0:e.preventCancel,i=e==null?void 0:e.preventClose,n=e==null?void 0:e.signal;return n!==void 0&&function(s,a){if(!function(l){if(typeof l!="object"||l===null)return!1;try{return typeof l.aborted=="boolean"}catch{return!1}}(s))throw new TypeError(`${a} is not an AbortSignal.`)}(n,`${r} has member 'signal' that`),{preventAbort:!!t,preventCancel:!!o,preventClose:!!i,signal:n}}Object.defineProperties(K.prototype,{close:{enumerable:!0},enqueue:{enumerable:!0},error:{enumerable:!0},desiredSize:{enumerable:!0}}),v(K.prototype.close,"close"),v(K.prototype.enqueue,"enqueue"),v(K.prototype.error,"error"),typeof Symbol.toStringTag=="symbol"&&Object.defineProperty(K.prototype,Symbol.toStringTag,{value:"ReadableStreamDefaultController",configurable:!0});var z=class{constructor(e={},r={}){e===void 0?e=null:Ct(e,"First parameter");const t=or(r,"Second parameter"),o=function(i,n){N(i,n);const s=i,a=s==null?void 0:s.autoAllocateChunkSize,l=s==null?void 0:s.cancel,u=s==null?void 0:s.pull,h=s==null?void 0:s.start,c=s==null?void 0:s.type;return{autoAllocateChunkSize:a===void 0?void 0:xr(a,`${n} has member 'autoAllocateChunkSize' that`),cancel:l===void 0?void 0:xo(l,s,`${n} has member 'cancel' that`),pull:u===void 0?void 0:Do(u,s,`${n} has member 'pull' that`),start:h===void 0?void 0:No(h,s,`${n} has member 'start' that`),type:c===void 0?void 0:Qo(c,`${n} has member 'type' that`)}}(e,"First parameter");if(et(this),o.type==="bytes"){if(t.size!==void 0)throw new RangeError("The strategy for a byte stream cannot have a size function");(function(i,n,s){const a=Object.create(J.prototype);let l,u,h;l=n.start!==void 0?()=>n.start(a):()=>{},u=n.pull!==void 0?()=>n.pull(a):()=>g(void 0),h=n.cancel!==void 0?f=>n.cancel(f):()=>g(void 0);const c=n.autoAllocateChunkSize;if(c===0)throw new TypeError("autoAllocateChunkSize must be greater than 0");Gt(i,a,l,u,h,s,c)})(this,o,ze(t,0))}else{const i=tr(t);(function(n,s,a,l){const u=Object.create(K.prototype);let h,c,f;h=s.start!==void 0?()=>s.start(u):()=>{},c=s.pull!==void 0?()=>s.pull(u):()=>g(void 0),f=s.cancel!==void 0?y=>s.cancel(y):()=>g(void 0),mo(n,u,h,c,f,a,l)})(this,o,ze(t,1),i)}}get locked(){if(!G(this))throw ie("locked");return ee(this)}cancel(e=void 0){return G(this)?ee(this)?d(new TypeError("Cannot cancel a stream that already has a reader")):M(this,e):d(ie("cancel"))}getReader(e=void 0){if(!G(this))throw ie("getReader");return function(r,t){N(r,t);const o=r==null?void 0:r.mode;return{mode:o===void 0?void 0:jo(o,`${t} has member 'mode' that`)}}(e,"First parameter").mode===void 0?we(this):Xt(this)}pipeThrough(e,r={}){if(!G(this))throw ie("pipeThrough");V(e,1,"pipeThrough");const t=function(i,n){N(i,n);const s=i==null?void 0:i.readable;Rr(s,"readable","ReadableWritablePair"),Dr(s,`${n} has member 'readable' that`);const a=i==null?void 0:i.writable;return Rr(a,"writable","ReadableWritablePair"),eo(a,`${n} has member 'writable' that`),{readable:s,writable:a}}(e,"First parameter"),o=ft(r,"Second parameter");if(ee(this))throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");if(Re(t.writable))throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");return qe(dt(this,t.writable,o.preventClose,o.preventAbort,o.preventCancel,o.signal)),t.readable}pipeTo(e,r={}){if(!G(this))return d(ie("pipeTo"));if(e===void 0)return d("Parameter 1 is required in 'pipeTo'.");if(!ge(e))return d(new TypeError("ReadableStream.prototype.pipeTo's first argument must be a WritableStream"));let t;try{t=ft(r,"Second parameter")}catch(o){return d(o)}return ee(this)?d(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream")):Re(e)?d(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream")):dt(this,e,t.preventClose,t.preventAbort,t.preventCancel,t.signal)}tee(){if(!G(this))throw ie("tee");return Ee($o(this))}values(e=void 0){if(!G(this))throw ie("values");return function(r,t){const o=we(r),i=new Bt(o,t),n=Object.create(Ft);return n._asyncIteratorImpl=i,n}(this,function(r,t){return N(r,t),{preventCancel:!!(r==null?void 0:r.preventCancel)}}(e,"First parameter").preventCancel)}[$e](e){return this.values(e)}static from(e){return Mo(e)}};function Le(e,r,t,o=1,i=()=>1){const n=Object.create(z.prototype);return et(n),mo(n,Object.create(K.prototype),e,r,t,o,i),n}function ht(e,r,t){const o=Object.create(z.prototype);return et(o),Gt(o,Object.create(J.prototype),e,r,t,0,void 0),o}function et(e){e._state="readable",e._reader=void 0,e._storedError=void 0,e._disturbed=!1}function G(e){return!!C(e)&&!!Object.prototype.hasOwnProperty.call(e,"_readableStreamController")&&e instanceof z}function ee(e){return e._reader!==void 0}function M(e,r){if(e._disturbed=!0,e._state==="closed")return g(void 0);if(e._state==="errored")return d(e._storedError);Me(e);const t=e._reader;if(t!==void 0&&de(t)){const o=t._readIntoRequests;t._readIntoRequests=new L,o.forEach(i=>{i._closeSteps(void 0)})}return H(e._readableStreamController[Br](r),We)}function Me(e){e._state="closed";const r=e._reader;if(r!==void 0&&(qt(r),Z(r))){const t=r._readRequests;r._readRequests=new L,t.forEach(o=>{o._closeSteps()})}}function yo(e,r){e._state="errored",e._storedError=r;const t=e._reader;t!==void 0&&($r(t,r),Z(t)?jt(t,r):Zt(t,r))}function ie(e){return new TypeError(`ReadableStream.prototype.${e} can only be used on a ReadableStream`)}function vo(e,r){N(e,r);const t=e==null?void 0:e.highWaterMark;return Rr(t,"highWaterMark","QueuingStrategyInit"),{highWaterMark:Mr(t)}}Object.defineProperties(z,{from:{enumerable:!0}}),Object.defineProperties(z.prototype,{cancel:{enumerable:!0},getReader:{enumerable:!0},pipeThrough:{enumerable:!0},pipeTo:{enumerable:!0},tee:{enumerable:!0},values:{enumerable:!0},locked:{enumerable:!0}}),v(z.from,"from"),v(z.prototype.cancel,"cancel"),v(z.prototype.getReader,"getReader"),v(z.prototype.pipeThrough,"pipeThrough"),v(z.prototype.pipeTo,"pipeTo"),v(z.prototype.tee,"tee"),v(z.prototype.values,"values"),typeof Symbol.toStringTag=="symbol"&&Object.defineProperty(z.prototype,Symbol.toStringTag,{value:"ReadableStream",configurable:!0}),Object.defineProperty(z.prototype,$e,{value:z.prototype.values,writable:!0,configurable:!0});var go=e=>e.byteLength;v(go,"size");var jr=class{constructor(e){V(e,1,"ByteLengthQueuingStrategy"),e=vo(e,"First parameter"),this._byteLengthQueuingStrategyHighWaterMark=e.highWaterMark}get highWaterMark(){if(!_t(this))throw bt("highWaterMark");return this._byteLengthQueuingStrategyHighWaterMark}get size(){if(!_t(this))throw bt("size");return go}};function bt(e){return new TypeError(`ByteLengthQueuingStrategy.prototype.${e} can only be used on a ByteLengthQueuingStrategy`)}function _t(e){return!!C(e)&&!!Object.prototype.hasOwnProperty.call(e,"_byteLengthQueuingStrategyHighWaterMark")&&e instanceof jr}Object.defineProperties(jr.prototype,{highWaterMark:{enumerable:!0},size:{enumerable:!0}}),typeof Symbol.toStringTag=="symbol"&&Object.defineProperty(jr.prototype,Symbol.toStringTag,{value:"ByteLengthQueuingStrategy",configurable:!0});var wo=()=>1;v(wo,"size");var Or=class{constructor(e){V(e,1,"CountQueuingStrategy"),e=vo(e,"First parameter"),this._countQueuingStrategyHighWaterMark=e.highWaterMark}get highWaterMark(){if(!mt(this))throw pt("highWaterMark");return this._countQueuingStrategyHighWaterMark}get size(){if(!mt(this))throw pt("size");return wo}};function pt(e){return new TypeError(`CountQueuingStrategy.prototype.${e} can only be used on a CountQueuingStrategy`)}function mt(e){return!!C(e)&&!!Object.prototype.hasOwnProperty.call(e,"_countQueuingStrategyHighWaterMark")&&e instanceof Or}function Yo(e,r,t){return $(e,t),o=>U(e,r,[o])}function Ho(e,r,t){return $(e,t),o=>he(e,r,[o])}function Vo(e,r,t){return $(e,t),(o,i)=>U(e,r,[o,i])}function Uo(e,r,t){return $(e,t),o=>U(e,r,[o])}Object.defineProperties(Or.prototype,{highWaterMark:{enumerable:!0},size:{enumerable:!0}}),typeof Symbol.toStringTag=="symbol"&&Object.defineProperty(Or.prototype,Symbol.toStringTag,{value:"CountQueuingStrategy",configurable:!0});var Wr=class{constructor(e={},r={},t={}){e===void 0&&(e=null);const o=or(r,"Second parameter"),i=or(t,"Third parameter"),n=function(c,f){N(c,f);const y=c==null?void 0:c.cancel,E=c==null?void 0:c.flush,O=c==null?void 0:c.readableType,W=c==null?void 0:c.start,q=c==null?void 0:c.transform,R=c==null?void 0:c.writableType;return{cancel:y===void 0?void 0:Uo(y,c,`${f} has member 'cancel' that`),flush:E===void 0?void 0:Yo(E,c,`${f} has member 'flush' that`),readableType:O,start:W===void 0?void 0:Ho(W,c,`${f} has member 'start' that`),transform:q===void 0?void 0:Vo(q,c,`${f} has member 'transform' that`),writableType:R}}(e,"First parameter");if(n.readableType!==void 0)throw new RangeError("Invalid readableType specified");if(n.writableType!==void 0)throw new RangeError("Invalid writableType specified");const s=ze(i,0),a=tr(i),l=ze(o,1),u=tr(o);let h;(function(c,f,y,E,O,W){function q(){return f}function R(_){return function(b,w){const m=b._transformStreamController;return b._backpressure?H(b._backpressureChangePromise,()=>{const S=b._writable;if(S._state==="erroring")throw S._storedError;return vt(m,w)}):vt(m,w)}(c,_)}function T(_){return function(b,w){const m=b._transformStreamController;if(m._finishPromise!==void 0)return m._finishPromise;const S=b._readable;m._finishPromise=j((k,te)=>{m._finishPromise_resolve=k,m._finishPromise_reject=te});const B=m._cancelAlgorithm(w);return er(m),F(B,()=>(S._state==="errored"?ye(m,S._storedError):(x(S._readableStreamController,w),gr(m)),null),k=>(x(S._readableStreamController,k),ye(m,k),null)),m._finishPromise}(c,_)}function A(){return function(_){const b=_._transformStreamController;if(b._finishPromise!==void 0)return b._finishPromise;const w=_._readable;b._finishPromise=j((S,B)=>{b._finishPromise_resolve=S,b._finishPromise_reject=B});const m=b._flushAlgorithm();return er(b),F(m,()=>(w._state==="errored"?ye(b,w._storedError):(pe(w._readableStreamController),gr(b)),null),S=>(x(w._readableStreamController,S),ye(b,S),null)),b._finishPromise}(c)}function p(){return function(_){return sr(_,!1),_._backpressureChangePromise}(c)}function P(_){return function(b,w){const m=b._transformStreamController;if(m._finishPromise!==void 0)return m._finishPromise;const S=b._writable;m._finishPromise=j((k,te)=>{m._finishPromise_resolve=k,m._finishPromise_reject=te});const B=m._cancelAlgorithm(w);return er(m),F(B,()=>(S._state==="errored"?ye(m,S._storedError):(Fe(S._writableStreamController,w),Ar(b),gr(m)),null),k=>(Fe(S._writableStreamController,k),Ar(b),ye(m,k),null)),m._finishPromise}(c,_)}c._writable=function(_,b,w,m,S=1,B=()=>1){const k=Object.create(ue.prototype);return to(k),uo(k,Object.create(Be.prototype),_,b,w,m,S,B),k}(q,R,A,T,y,E),c._readable=Le(q,p,P,O,W),c._backpressure=void 0,c._backpressureChangePromise=void 0,c._backpressureChangePromise_resolve=void 0,sr(c,!0),c._transformStreamController=void 0})(this,j(c=>{h=c}),l,u,s,a),function(c,f){const y=Object.create(ce.prototype);let E,O,W;E=f.transform!==void 0?q=>f.transform(q,y):q=>{try{return Ro(y,q),g(void 0)}catch(R){return d(R)}},O=f.flush!==void 0?()=>f.flush(y):()=>g(void 0),W=f.cancel!==void 0?q=>f.cancel(q):()=>g(void 0),function(q,R,T,A,p){R._controlledTransformStream=q,q._transformStreamController=R,R._transformAlgorithm=T,R._flushAlgorithm=A,R._cancelAlgorithm=p,R._finishPromise=void 0,R._finishPromise_resolve=void 0,R._finishPromise_reject=void 0}(c,y,E,O,W)}(this,n),n.start!==void 0?h(n.start(this._transformStreamController)):h(void 0)}get readable(){if(!yt(this))throw gt("readable");return this._readable}get writable(){if(!yt(this))throw gt("writable");return this._writable}};function yt(e){return!!C(e)&&!!Object.prototype.hasOwnProperty.call(e,"_transformStreamController")&&e instanceof Wr}function So(e,r){x(e._readable._readableStreamController,r),rt(e,r)}function rt(e,r){er(e._transformStreamController),Fe(e._writable._writableStreamController,r),Ar(e)}function Ar(e){e._backpressure&&sr(e,!1)}function sr(e,r){e._backpressureChangePromise!==void 0&&e._backpressureChangePromise_resolve(),e._backpressureChangePromise=j(t=>{e._backpressureChangePromise_resolve=t}),e._backpressure=r}Object.defineProperties(Wr.prototype,{readable:{enumerable:!0},writable:{enumerable:!0}}),typeof Symbol.toStringTag=="symbol"&&Object.defineProperty(Wr.prototype,Symbol.toStringTag,{value:"TransformStream",configurable:!0});var ce=class{constructor(){throw new TypeError("Illegal constructor")}get desiredSize(){if(!Ve(this))throw Ue("desiredSize");return Zr(this._controlledTransformStream._readable._readableStreamController)}enqueue(e=void 0){if(!Ve(this))throw Ue("enqueue");Ro(this,e)}error(e=void 0){if(!Ve(this))throw Ue("error");var r;r=e,So(this._controlledTransformStream,r)}terminate(){if(!Ve(this))throw Ue("terminate");(function(e){const r=e._controlledTransformStream;pe(r._readable._readableStreamController);const t=new TypeError("TransformStream terminated");rt(r,t)})(this)}};function Ve(e){return!!C(e)&&!!Object.prototype.hasOwnProperty.call(e,"_controlledTransformStream")&&e instanceof ce}function er(e){e._transformAlgorithm=void 0,e._flushAlgorithm=void 0,e._cancelAlgorithm=void 0}function Ro(e,r){const t=e._controlledTransformStream,o=t._readable._readableStreamController;if(!Pe(o))throw new TypeError("Readable side is not in a state that permits enqueue");try{Te(o,r)}catch(n){throw rt(t,n),t._readable._storedError}(function(n){return!po(n)})(o)!==t._backpressure&&sr(t,!0)}function vt(e,r){return H(e._transformAlgorithm(r),void 0,t=>{throw So(e._controlledTransformStream,t),t})}function Ue(e){return new TypeError(`TransformStreamDefaultController.prototype.${e} can only be used on a TransformStreamDefaultController`)}function gr(e){e._finishPromise_resolve!==void 0&&(e._finishPromise_resolve(),e._finishPromise_resolve=void 0,e._finishPromise_reject=void 0)}function ye(e,r){e._finishPromise_reject!==void 0&&(qe(e._finishPromise),e._finishPromise_reject(r),e._finishPromise_resolve=void 0,e._finishPromise_reject=void 0)}function gt(e){return new TypeError(`TransformStream.prototype.${e} can only be used on a TransformStream`)}Object.defineProperties(ce.prototype,{enqueue:{enumerable:!0},error:{enumerable:!0},terminate:{enumerable:!0},desiredSize:{enumerable:!0}}),v(ce.prototype.enqueue,"enqueue"),v(ce.prototype.error,"error"),v(ce.prototype.terminate,"terminate"),typeof Symbol.toStringTag=="symbol"&&Object.defineProperty(ce.prototype,Symbol.toStringTag,{value:"TransformStreamDefaultController",configurable:!0});/*! Bundled license information:

web-streams-polyfill/dist/ponyfill.mjs:
  (**
   * @license
   * web-streams-polyfill v4.0.0
   * Copyright 2024 Mattias Buelens, Diwank Singh Tomer and other contributors.
   * This code is released under the MIT license.
   * SPDX-License-Identifier: MIT
   *)
*/export{jr as ByteLengthQueuingStrategy,Or as CountQueuingStrategy,J as ReadableByteStreamController,z as ReadableStream,le as ReadableStreamBYOBReader,ve as ReadableStreamBYOBRequest,K as ReadableStreamDefaultController,ae as ReadableStreamDefaultReader,Wr as TransformStream,ce as TransformStreamDefaultController,ue as WritableStream,Be as WritableStreamDefaultController,X as WritableStreamDefaultWriter};
